<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Планировщик: Облачная версия</title>
    
    <!-- React и ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js (для 3D) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, addDoc, deleteDoc, onSnapshot, serverTimestamp, query, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- НАСТРОЙКИ ВАШЕГО СЕРВЕРА ---
        const MY_FIREBASE_CONFIG = {
            apiKey: "AIzaSyDw93skiZDxjAdY_CXreJyWSAifwV6243I",
            authDomain: "db-for-sites.firebaseapp.com",
            projectId: "db-for-sites",
            storageBucket: "db-for-sites.firebasestorage.app",
            messagingSenderId: "337767573843",
            appId: "1:337767573843:web:75e6214ff6ee70cfdcd9a6",
            measurementId: "G-3YSQ1GG4V4"
        };

        // Глобальная инициализация Firebase
        window.initFirebase = async () => {
             // 1. Пытаемся взять ваши личные настройки
            let firebaseConfig = MY_FIREBASE_CONFIG;
            let appId = 'my-site-planner'; 

            // 2. Если их нет, пытаемся взять настройки среды (для демо)
            if (!firebaseConfig.apiKey) {
                try {
                    firebaseConfig = JSON.parse(window.__firebase_config || '{}');
                    appId = window.__app_id || 'default-app';
                } catch (e) {
                    console.warn("Нет конфигурации Firebase.");
                }
            }
            
            if (!firebaseConfig.apiKey) {
                console.warn("Firebase config not found. Local mode only.");
                return null;
            }

            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const db = getFirestore(app);

            return { auth, db, appId, signInAnonymously, signInWithCustomToken, onAuthStateChanged, collection, doc, setDoc, addDoc, deleteDoc, onSnapshot, serverTimestamp, query, orderBy };
        };
    </script>

    <style>
        body { background-color: #f3f4f6; overflow: hidden; }
        .grid-pattern {
            background-image: 
                linear-gradient(#e5e7eb 1px, transparent 1px), 
                linear-gradient(90deg, #e5e7eb 1px, transparent 1px);
        }
        .no-select { user-select: none; -webkit-user-select: none; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- Вспомогательные функции ---
        const getHexColor = (tailwindClass) => {
            if (tailwindClass.includes('red')) return 0xfca5a5;
            if (tailwindClass.includes('green')) return 0x86efac;
            if (tailwindClass.includes('blue')) return 0x93c5fd;
            if (tailwindClass.includes('slate')) return 0xcbd5e1;
            if (tailwindClass.includes('yellow')) return 0xfde047;
            return 0xcccccc;
        };

        const DEFAULT_SITE_CONFIG = { width: 24.5, height: 24.5 };
        const DEFAULT_OBJECTS = [
            { id: 'house', label: 'Дом', w: 12, h: 10, height: 6, x: 3, y: 3, color: 'bg-red-100 border-red-500' },
            { id: 'cont1', label: 'Хоз. блок', w: 12.2, h: 2.44, height: 2.9, x: 12, y: 21, color: 'bg-green-100 border-green-500' },
            { id: 'parking', label: 'Парковка', w: 6, h: 5, height: 0.1, x: 18, y: 0.5, color: 'bg-slate-100 border-slate-400 border-dashed' }
        ];

        // --- Компонент 3D Сцены (без изменений) ---
        const Scene3D = ({ objects, siteConfig }) => {
            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            
            useEffect(() => {
                const width = mountRef.current.clientWidth;
                const height = mountRef.current.clientHeight;
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f9ff);
                scene.fog = new THREE.Fog(0xf0f9ff, 20, 100);
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                camera.position.set(siteConfig.width * 1.5, siteConfig.width, siteConfig.height * 1.5); 

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                mountRef.current.appendChild(renderer.domElement);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.maxPolarAngle = Math.PI / 2 - 0.05;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(20, 50, 20);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                scene.add(dirLight);

                const groundGeo = new THREE.PlaneGeometry(100, 100);
                const groundMat = new THREE.MeshStandardMaterial({ color: 0xe5e7eb });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.05;
                ground.receiveShadow = true;
                scene.add(ground);

                const plotGeo = new THREE.PlaneGeometry(siteConfig.width, siteConfig.height);
                const plotMat = new THREE.MeshStandardMaterial({ color: 0xf0fdf4, side: THREE.DoubleSide });
                const plot = new THREE.Mesh(plotGeo, plotMat);
                plot.rotation.x = -Math.PI / 2;
                plot.receiveShadow = true;
                scene.add(plot);

                const gridHelper = new THREE.GridHelper(Math.max(siteConfig.width, siteConfig.height), Math.max(siteConfig.width, siteConfig.height));
                scene.add(gridHelper);

                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                const handleResize = () => {
                    if (!mountRef.current) return;
                    const w = mountRef.current.clientWidth;
                    const h = mountRef.current.clientHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    if (mountRef.current && renderer.domElement) mountRef.current.removeChild(renderer.domElement);
                    renderer.dispose();
                };
            }, []);

            useEffect(() => {
                if (!sceneRef.current) return;
                const scene = sceneRef.current;
                for (let i = scene.children.length - 1; i >= 0; i--) {
                    if (scene.children[i].userData.isBuilding) scene.remove(scene.children[i]);
                }
                objects.forEach(obj => {
                    const geometry = new THREE.BoxGeometry(obj.w, obj.height || 0.1, obj.h);
                    const material = new THREE.MeshStandardMaterial({ color: getHexColor(obj.color), roughness: 0.7, metalness: 0.1 });
                    const cube = new THREE.Mesh(geometry, material);
                    const centerX = obj.x + obj.w / 2 - siteConfig.width / 2;
                    const centerZ = obj.y + obj.h / 2 - siteConfig.height / 2;
                    cube.position.set(centerX, (obj.height || 0.1) / 2, centerZ);
                    cube.castShadow = true;
                    cube.receiveShadow = true;
                    cube.userData = { isBuilding: true };
                    const edges = new THREE.EdgesGeometry(geometry);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.2, transparent: true }));
                    cube.add(line);
                    scene.add(cube);
                });
            }, [objects, siteConfig]);

            return <div ref={mountRef} className="w-full h-full cursor-move" />;
        };

        // --- Главное приложение ---
        const App = () => {
            const PIXELS_PER_METER = 20;

            const [viewMode, setViewMode] = useState('2d');
            const [selectedId, setSelectedId] = useState(null);
            const containerRef = useRef(null);

            const [siteConfig, setSiteConfig] = useState(DEFAULT_SITE_CONFIG);
            const [objects, setObjects] = useState(DEFAULT_OBJECTS);
            
            const [fb, setFb] = useState(null);
            const [user, setUser] = useState(null);
            const [projects, setProjects] = useState([]);
            const [currentProjectId, setCurrentProjectId] = useState(null);
            const [projectName, setProjectName] = useState("Новый проект");
            const [isLoading, setIsLoading] = useState(true);
            const [saveStatus, setSaveStatus] = useState("");
            
            // Новое состояние для глобальных ошибок
            const [globalError, setGlobalError] = useState(null);

            // 1. Инициализация Firebase
            useEffect(() => {
                const init = async () => {
                    if (window.initFirebase) {
                        try {
                            const fbInstance = await window.initFirebase();
                            if (fbInstance) {
                                setFb(fbInstance);
                                const { auth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } = fbInstance;
                                
                                const authToken = window.__initial_auth_token;
                                if (authToken) {
                                    await signInWithCustomToken(auth, authToken);
                                } else {
                                    await signInAnonymously(auth);
                                }
                                onAuthStateChanged(auth, (u) => setUser(u));
                            }
                        } catch (err) {
                            console.error("Firebase init error:", err);
                            // Не блокируем интерфейс, просто работаем локально (но без сохранений)
                        }
                    }
                    setIsLoading(false);
                };
                init();
            }, []);

            // 2. Загрузка списка проектов с обработкой ошибок блокировщика
            useEffect(() => {
                if (!user || !fb) return;
                const { db, appId, collection, onSnapshot, query } = fb;

                const q = query(collection(db, 'artifacts', appId, 'users', user.uid, 'designs')); 

                const unsubscribe = onSnapshot(q, (snapshot) => {
                    setGlobalError(null); // Очищаем ошибку при успехе
                    const loadedProjects = snapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));
                    
                    loadedProjects.sort((a, b) => (b.updatedAt?.seconds || 0) - (a.updatedAt?.seconds || 0));
                    setProjects(loadedProjects);

                    if (loadedProjects.length > 0 && !currentProjectId) {
                        loadProject(loadedProjects[0]);
                    }
                }, (error) => {
                    console.error("Firestore Error:", error);
                    // Обработка ошибки блокировщика
                    if (error.code === 'failed-precondition' || error.message.includes('BLOCKED') || error.message.includes('offline')) {
                        setGlobalError("Соединение с базой данных заблокировано. Пожалуйста, отключите AdBlock, uBlock или VPN для этого сайта, чтобы сохранять проекты.");
                    } else {
                        setGlobalError(`Ошибка синхронизации: ${error.message}`);
                    }
                });

                return () => unsubscribe();
            }, [user, fb]);

            // --- Функции управления проектами ---

            const createNewProject = async () => {
                if (!user || !fb) return alert("База данных недоступна. Отключите блокировщики рекламы.");
                const { db, appId, collection, addDoc, serverTimestamp } = fb;

                const newProject = {
                    name: `Проект ${projects.length + 1}`,
                    siteConfig: DEFAULT_SITE_CONFIG,
                    objects: DEFAULT_OBJECTS,
                    updatedAt: serverTimestamp